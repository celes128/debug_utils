#pragma once

#include <vector>
#include <string>
#include "Key.h"
#include "ConsoleHistory.h"
#include "EditBox.h"
#include "Interpreter.h"
#include "OvwRingBuf.h"

#define IN
#define OUT
#define OPTIONAL

namespace dbgutils {

	//// CONSOLE_EVENT are optional flags returned by the handle_character and handle_key functions.
	//using CONSOLE_EVENT = int;
	//enum {
	//	// Both the command line string and the caret did not change.
	//	CONSOLE_EVENT_NONE					= 1,

	//	// The value of the caret changed.
	//	CONSOLE_EVENT_CARET_CHANGED			= 2,
	//	
	//	// At least one character in the command line string changed.
	//	CONSOLE_EVENT_CMDLINE_STR_CHANGED	= 4,
	//	
	//	// The command line was sent to the interpreter and executed.
	//	CONSOLE_EVENT_CMDLINE_EXECUTED		= 8
	//};

	class Console {
	public:
		Console(Interpreter interpreter = Interpreter(), size_t historyCapacity = 32, size_t outputCapacity = 32);

		//		ACCESSORS
		//
		// cmdline returns the string in the command line.
		const std::wstring &cmdline() const;

		auto *get_interpreter() { return &m_interpreter; }

		// TEMPORARY
		// last_cmdline returns the last commandline string that was executed.
		// If there is none then the empty string is returned.
		const std::wstring &last_cmdline() const
		{
			return m_lastCmdlineStr;
		}

		// caret returns the position of the caret in the command line string.
		size_t caret() const;

		// output_size returns the number of strings stored in the output buffer.
		size_t output_size() const { return m_output.size(); }

		// output_capacity returns the maximum number of strings that the ouput buffer can store.
		size_t output_capacity() const { return m_output.capacity(); }

		// get_output returns a specific output string.
		//
		// INPUT
		//	size_t i
		//		Index of the output string to obtain.
		//		i = 0 corresponds to the latest output i.e. the output generated by
		//		the most recent command.
		//		i = output_size() - 1 corresponds to the oldest output i.e. the output generated by
		//		the odlest command.
		std::wstring get_output(size_t i) const;

		//		MANIPULATORS
		//
		// All handle_xxx functions return true iff the command line content or the caret changed.
		bool handle_character(IN wchar_t c);
		bool handle_key(Key key);

	private:
		const EditBox & cur_editbox() const;
		EditBox & cur_editbox();

		// ENTER/RETURN key press handling.
		// Execute the command line.
		bool handle_enter_key();
		void exec_cmdline_and_store_output();
		void add_cmdline_to_history_and_reset_iteration();

		bool handle_up_key();
		bool handle_down_key();

		void clear_editboxes_and_set_up_new_one();
		bool cmdline_is_empty() const;

	private:
		// Command interpreter.
		Interpreter					m_interpreter;

		// The history stores the content of previous command lines
		// when the user presses the ENTER/RETURN key.
		ConsoleHistory				m_history;

		// These editboxes are used to manage the command line.
		// When the user presses the UP key to look up in the history,
		// a new edit box is created and becomes the current one.
		std::vector<EditBox>		m_editboxes;
		size_t						m_i{ 0 };

		// Output strings generated by the interpreter and commands
		// when the user presses the ENTER/RETURN key.
		OvwRingBuf<std::wstring>	m_output;

		// TEMPORARY
		std::wstring	m_lastCmdlineStr;
	};
}